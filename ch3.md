# 3장. 컴퓨터 시스템의 동작원리

1. **컴퓨터 시스템의 구조** - CPU, 메모리, 디스크, 외부장치
2. **CPU 연산과 I/O 연산** - 외부장치마다 로컬버퍼 달려있음. 다 차거나 지정된 간이 넘으면 컨트롤러가 인터럽트 발생시켜서 전달
3. 인터럽트의 일반적 기능 - 하드웨어 인터럽트, 소프트웨어 인터럽트(트랩, 예외사항 or 시스템콜)
4. 인터럽트 핸들링 - PCG에 레지스터값, 코드메모리 주소, HW 상태 저장 후 CPU제어권이 인터럽트 처리루틴으로 넘어감
5. 입출력 구조 - 동기식 입출력, 비동기식 입출력 차이
6. DMA - CPU 앞에서 외부장치의 로컬버퍼에서 메모리로 읽어오는 일을 CPU 대신 해줌
7. 저장장치의 구조 - 휘발성, 비휘발성 디스크
8. 저장장치의 계층 구조 - 가성비를 위해 캐싱. 꼭 필요한 부분만 메모리에 올리고 나머지는 디스크의 스왑 영역에 올린다(스왑 아웃)
9. 하드웨어의 보안 - 시스템콜이 작동될 때마다 사용자모드1,  커널모드0인지 modebit로 구분함
10. 메모리 보안 - 기준 레지스터, 한계 레지스터
11. CPU 보호 - 타이머를 이용해서 인터럽트
12. 시스템 콜을 이용한 입출력 수행 - 트랩 발생시켜서 제어권이 프로그램에서 OS로, 작업이 끝나면 다시 프로그램으로 넘어옴

### 전반적인 컴퓨터 구조

---

![컴퓨터구조](/image/architecture.jpg)

- CPU
  - ALU
  - CU
  - registe조
  - cache memory
  - interrupt line - CPU가 하나의 명령을 실행할 때마다 인터럽트 라인이 인터럽트를 감지했는지 확인한다
  - modebit - CPU가 보안과 관련된 명령을 수행하기 전에 modebit값을 검사해서 0인 경우에만(커널모드) 일 때만 실행한다. 시스템 보안과 관련된 명령은 커널모드에서 OS에 의해서만 수행될 수 있따.
- Memory
  - 프로세스마다 달려 있는 PCB(실행중인 프로세스의 메모리주소, 레지스터값, 하드웨어상태… 저장됨)
- 컨트롤러
  - DMA controller - CPU가 너무 자주 인터럽트 되서 효율이 떨어지는 것을 막기 위해 블록 단위로 데이터를 받다가 CPU에게 한꺼번에 넘겨준다. (CPU의 인터럽트 빈도가 줄어듬)
  - timer - 하나의 프로세스나 외부기기에 CPU자원이 독점되는 것을 막기 위해 정해진 시간이 지나면 인터럽트를 발생시켜서 자원을 반환시키는 하드웨어이다. (그리고 시분할 시스템에서 현재시간을 계산하기 위해 사용된다)
- 로컬버퍼 - 장치마다 달려있는 데이터 임시저장을 위한 메모리. 요청된 데이터가 다 쌓이면 장치 컨트롤러에 보내면 컨트롤러가 인터럽트를 발생시켜서 CPU에 보고한다
- 보조 기억장치 - 파일 시스템용 + 메모리 연장공간용(메모리의 공간이 모자르면 보조기억장치의 스왑 영역을 통해서 메모리에 올라온 프로그램 일부를 디스크에 스왑아웃 했다가 다시 메모리영역으로 가져간다. 일종의 캐싱 기법)

### 인터럽트

---

**인터럽트란**

- 컨트롤러들이 CPU의 서비스가 필요할 떄 이를 통보하는 방법

**인터럽트 종류**

- 인터럽트를 일으키는 주체에 따라
  - 하드웨어 인터럽트 - 하드웨어 장치가 CPU에서 실행될 인터럽트 라인을 지정함
  - 소프트웨어 인터럽트(트랩) : exception, system call 두가지 경우. 이 경우 CPU의 제어권이 프로세스에서 OS로 넘어갔다가 처리 후 다시 프로세스로 돌아오게 된다.
    - exception 인 경우: 비정상적인 작업, 권한이 없는 작업 시도시에 발생
    - system call: 사용자 프로그램이 운영체제의 서비스를 직접 요청할 때 발생
- 인터럽트가 발생하면 처리해야될 일의 절차를 인터럽트 핸들링 이라 한다.

**인터럽트 처리 절차(인터럽트 핸들링)**

1. CPU 자원으로 돌아가는 프로그램이 데이터를 요청함(소프트웨어 인터럽트 예시)
2. 신호가 디스크에 전달된다.
3. 디스크 컨트롤러가 데이터를 로컬버퍼에 쌓음 → 다 쌓였으면 컨트롤러가 인터럽트로 CPU에 보고한다
4. CPU는 OS 커널 상에서 미리 인터럽트 벡터에 정의되어 있는 함수(인터럽트 처리루틴 or 핸들러) 실행 → 인터럽트 핸들러가 인터럽트 처리
5. 처리 끝나면 CPU는 기존에 하던 일을 마저 하러간다(아까 실행하던 프로세스의 PCB에 저장되어 있는 부분부터 다시 실행 시작)

### 외부장치와의 I/O 방식 - 동기식, 비동기식 입출력

---

- 외부 I/O장치가 몇개 없던 초창기에는 OS가 직접 주기적으로 I/O장치를 확인함(polling 방식)
- 오늘날에는 I/O장치가 너무 많아져서 대신 event driven 방식으로 인터럽트를 통해 처리함

![프로세스 상태](/image/process_status.png)

- 프로세스가 OS에 입출력 요청을 하는데 입출력 요청을 한 프로세스가 그 작업이 끝날 때까지 block상태로 대기하고 있으면 **동기식 입출력 방식**이다
  - 동기식 입출력에서는 요청한 순서대로 프로세스를 진행해야 되므로 장치별로 큐를 두게 된다. **(다수의 프로세스들이 입출력을 요청하게 되면 동기성을 보장하기 위해 요청한 순서대로 처리하게 된다.)**
- 프로세스가 입출력이 진행되는 동안 다시 CPU자원을 획득해서 다른 처리를 하고 있다가 요청한 데이터가 넘어오면 I/O작업이 끝났다는 인터럽트가 발생해서 다시 해당 작업으로 되돌아 가는 방식의 I/O방식이 **비동기식 입출력**이다

### OS가 사용자 프로그램으로부터 메모리 보안을 지키는 방식 - 기준레지스터, 한계레지스터

---

- 기준레지스터(프로그램의 시작 주소), 한계 레지스터(프로그램의 길이) - 이 2가지 기준을 통해 사용자의 프로세스가 접근하려는 메모리부분이 권한이 있는 곳인지 체크해서 메모리를 보호한다.
- 사용자 모드일때는 이 2개 기준을 사용해서 메모리를 보호하고, 커널모드에서는 메모리에 무제한으로 접근이 가능하다.

### 유저 프로그램이 시스템 명령을 사용해야할 때 - 시스템콜

---

- 입출력 명령 같은 특권명령은 OS에 정의되어있다. 유저 프로그램은 OS에 시스템콜을 한다. 시스템콜(=소프트웨어 인터럽트, 트랩)을 하면 CPU 제어권이 프로그램에서 OS로 넘어오고, OS가 시스템 콜로 정의된 명령을 수행하여 마치면 다시 인터럽트가 발생하여 자원을 반환하고 프로그램에 CPU자원이 넘어간다.
